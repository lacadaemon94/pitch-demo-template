// src/index.ts
import { ClientRequest } from "http";
import { env, stdout } from "process";
import colors from "picocolors";

// src/css-loader.ts
import { URL } from "url";
import axios from "axios";
import CleanCss from "clean-css";
var CssLoader = class {
  constructor(options, fileCache) {
    this.options = options;
    this.fileCache = fileCache;
    this.isRelativeUrlRegex = /..?\/.+?\.(?:woff2?|eot|ttf|otf|svg)/gi;
  }
  async loadAll(urls, isDevServer) {
    let cssContent = "";
    for (const url of urls) {
      const css = await this.load(url);
      const cssNormalized = this.normalizeUrls(css.trim(), url);
      cssContent += cssNormalized + "\n";
    }
    return this.formatCss(cssContent, isDevServer);
  }
  formatCss(cssContent, isDevServer) {
    if (!isDevServer && this.options.minifyCss) {
      return this.minify(cssContent);
    }
    return cssContent.trim();
  }
  minify(cssContent) {
    return new CleanCss().minify(cssContent).styles;
  }
  normalizeUrls(cssContent, cssUrl) {
    return cssContent.replaceAll(this.isRelativeUrlRegex, (match) => {
      const urlObject = new URL(match, cssUrl);
      return urlObject.href;
    });
  }
  async load(url) {
    const cachedFile = this.fileCache.get("css", url);
    if (cachedFile) {
      return cachedFile;
    }
    const userAgentWoff2 = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36";
    const response = await axios.request({
      method: "get",
      url,
      headers: {
        "User-Agent": userAgentWoff2
      }
    });
    this.fileCache.save("css", url, response.data);
    return response.data;
  }
};

// src/css-parser.ts
var CssParser = class {
  constructor() {
    this.fontSrcRegex = /(?:https?:)?\/\/.+?\.(?:woff2?|eot|ttf|otf|svg)/gi;
    this.googleFontsKitSrcRegex = /https:\/\/fonts\.gstatic\.com\/l\/font\?kit=[a-z0-9&=_-]+/gi;
    this.fontFilenameRegex = /[^/]+\.(?:woff2?|eot|ttf|otf|svg)/i;
    this.googleFontsFileRegex = /\?kit=([a-z0-9_-]+)/i;
    this.webfontProviders = [
      /https:\/\/fonts\.googleapis\.com\//i,
      /https:\/\/fonts\.gstatic\.com\//i,
      /https:\/\/fonts\.bunny\.net\//i,
      /https:\/\/api\.fontshare\.com\//i
    ];
  }
  parse(cssContent, base, assetsDir) {
    var _a, _b;
    const fonts = {};
    const fontSrcMatches = cssContent.matchAll(this.fontSrcRegex);
    const googleFontsKitSrcMatches = cssContent.matchAll(this.googleFontsKitSrcRegex);
    if (fontSrcMatches) {
      for (const fontSrcMatch of fontSrcMatches) {
        const url = fontSrcMatch.toString();
        const filenameMatch = url.match(this.fontFilenameRegex);
        if (filenameMatch) {
          const filename = filenameMatch[0];
          fonts[filename] = {
            url,
            localPath: base + (assetsDir ? assetsDir + "/" : "") + filename
          };
        }
      }
    }
    if (googleFontsKitSrcMatches) {
      for (const googleFontsKitSrcMatch of googleFontsKitSrcMatches) {
        const url = googleFontsKitSrcMatch.toString();
        const filename = (_b = (_a = url.match(this.googleFontsFileRegex)) == null ? void 0 : _a[1]) == null ? void 0 : _b.toString();
        if (filename) {
          fonts[filename + ".woff2"] = {
            url,
            localPath: base + (assetsDir ? assetsDir + "/" : "") + filename + ".woff2"
          };
        }
      }
    }
    return fonts;
  }
  parseBundleCss(cssContent, base, assetsDir) {
    const fonts = {};
    const webfontUrlsCss = /* @__PURE__ */ new Set([]);
    const matchedCssParts = [];
    const importRegex = /@import\s+(?:url\()?['"]?([^\s'"]+)['"]?\)?;/g;
    const fontFaceRegex = /@font-face\s*{[^}]*}/g;
    const imports = [...cssContent.matchAll(importRegex)];
    const fontFaces = [...cssContent.matchAll(fontFaceRegex)];
    fontFaces.forEach((match) => {
      const fontFace = match[0];
      const parsedFonts = this.parse(fontFace, base, assetsDir);
      for (const filename in parsedFonts) {
        const font = parsedFonts[filename];
        if (this.webfontProviders.some((regex) => regex.test(font.url))) {
          fonts[filename] = font;
          matchedCssParts.push(match[0]);
        }
      }
    });
    imports.forEach((match) => {
      const url = match[1];
      if (this.webfontProviders.some((regex) => regex.test(url))) {
        webfontUrlsCss.add(url);
        matchedCssParts.push(match[0]);
      }
    });
    return {
      fonts,
      webfontUrlsCss,
      matchedCssParts
    };
  }
};

// src/css-injector.ts
var CssInjector = class {
  constructor(options) {
    this.options = options;
  }
  injectAsStylesheet(html, base, cssPath) {
    if (this.options.async) {
      return this.injectAsync(html, base, cssPath);
    } else {
      return this.injectSync(html, base, cssPath);
    }
  }
  injectAsStyleTag(html, cssContent) {
    if (this.options.minifyCss) {
      return html.replace(
        /([ \t]*)<\/head>/,
        `$1$1<style>${cssContent}</style>
$1</head>`
      );
    }
    return html.replace(
      /([ \t]*)<\/head>/,
      `$1$1<style>
${cssContent.replace(/^/gm, "$1$1$1")}
$1$1</style>
$1</head>`
    );
  }
  injectAsync(html, base, cssPath) {
    return html.replace(
      /([ \t]*)<\/head>/,
      `$1$1<link rel="preload" as="style" href="${base}${cssPath}">
$1$1<link rel="stylesheet" media="print" onload="this.onload=null;this.removeAttribute('media');" href="${base}${cssPath}">
$1</head>`
    );
  }
  injectSync(html, base, cssPath) {
    return html.replace(
      /([ \t]*)<\/head>/,
      `$1$1<link rel="preload" as="style" href="${base}${cssPath}">
$1$1<link rel="stylesheet" href="${base}${cssPath}">
$1</head>`
    );
  }
};

// src/css-transformer.ts
var CssTransformer = class {
  transform(cssContent, fonts) {
    for (const fontFile in fonts) {
      const font = fonts[fontFile];
      cssContent = cssContent.replaceAll(font.url, font.localPath);
    }
    return cssContent;
  }
};

// src/font-loader.ts
import axios2 from "axios";
var FontLoader = class {
  constructor(fileCache) {
    this.fileCache = fileCache;
  }
  async load(url) {
    const cachedFile = this.fileCache.get("font", url);
    if (cachedFile) {
      return cachedFile;
    }
    const response = await axios2.request({
      method: "get",
      responseType: "arraybuffer",
      url
    });
    this.fileCache.save("font", url, response.data);
    return response.data;
  }
};

// src/index-html-processor.ts
var IndexHtmlProcessor = class {
  constructor() {
    this.webfontRegexes = [
      /<link[^>]+rel=['"]?stylesheet['"]?[^>]+href=['"]?(https:\/\/fonts\.googleapis\.com[^'">]+)['"]?[^>]*>/g,
      /<link[^>]+href=['"]?(https:\/\/fonts\.googleapis\.com[^'">]+)['"]?[^>]+rel=['"]?stylesheet['"]?[^>]*>/g,
      /<link[^>]+rel=['"]?stylesheet['"]?[^>]+href=['"]?(https:\/\/fonts\.bunny\.net[^'">]+)['"]?[^>]*>/g,
      /<link[^>]+href=['"]?(https:\/\/fonts\.bunny\.net[^'">]+)['"]?[^>]+rel=['"]?stylesheet['"]?[^>]*>/g,
      /<link[^>]+rel=['"]?stylesheet['"]?[^>]+href=['"]?(https:\/\/api\.fontshare\.com[^'">]+)['"]?[^>]*>/g,
      /<link[^>]+href=['"]?(https:\/\/api\.fontshare\.com[^'">]+)['"]?[^>]+rel=['"]?stylesheet['"]?[^>]*>/g
    ];
    this.preconnectRegexes = [
      /<link[^>]+rel=['"]?preconnect['"]?[^>]+href=['"]?https:\/\/fonts\.googleapis\.com['"]?[^>]*>/,
      /<link[^>]+href=['"]?https:\/\/fonts\.googleapis\.com['"]?[^>]+rel=['"]?preconnect['"]?[^>]*>/,
      /<link[^>]+rel=['"]?preconnect['"]?[^>]+href=['"]?https:\/\/fonts\.gstatic\.com['"]?[^>]*>/,
      /<link[^>]+href=['"]?https:\/\/fonts\.gstatic\.com['"]?[^>]+rel=['"]?preconnect['"]?[^>]*>/,
      /<link[^>]+rel=['"]?preconnect['"]?[^>]+href=['"]?https:\/\/fonts\.bunny\.net['"]?[^>]*>/,
      /<link[^>]+href=['"]?https:\/\/fonts\.bunny\.net['"]?[^>]+rel=['"]?preconnect['"]?[^>]*>/,
      /<link[^>]+rel=['"]?preconnect['"]?[^>]+href=['"]?https:\/\/api\.fontshare\.com['"]?[^>]*>/,
      /<link[^>]+href=['"]?https:\/\/api\.fontshare\.com['"]?[^>]+rel=['"]?preconnect['"]?[^>]*>/
    ];
  }
  parse(html) {
    const webfontUrls = /* @__PURE__ */ new Set();
    for (const regex of this.webfontRegexes) {
      const matches = html.matchAll(regex);
      if (matches) {
        for (const match of matches) {
          webfontUrls.add(match[1]);
        }
      }
    }
    return webfontUrls;
  }
  removeTags(html) {
    html = this.removePreconnectTags(html);
    html = this.removeWebfontTags(html);
    return html;
  }
  removePreconnectTags(html) {
    for (const regex of this.preconnectRegexes) {
      const removeRegex = new RegExp("[ 	]*" + regex.source + "(\r\n|\r|\n)?", "g");
      html = html.replace(removeRegex, "");
    }
    return html;
  }
  removeWebfontTags(html) {
    for (const regex of this.webfontRegexes) {
      const removeRegex = new RegExp("[ 	]*" + regex.source + "(\r\n|\r|\n)?", "g");
      html = html.replace(removeRegex, "");
    }
    return html;
  }
};

// src/file-cache.ts
import cache from "flat-cache";
var FileCache = class {
  constructor(options) {
    this.cacheID = "vite-plugin-webfont-dl";
    this.enabled = true;
    this.count = {
      css: 0,
      font: 0
    };
    this.hits = {
      css: 0,
      font: 0
    };
    if (options.cache === false) {
      this.enabled = false;
    }
    this.store = cache.create(this.cacheID);
    if (!this.enabled) {
      this.clear();
    }
    Object.keys(this.all()).forEach((key) => {
      if (key.startsWith("css::")) {
        this.count.css++;
      } else if (key.startsWith("font::")) {
        this.count.font++;
      }
    });
  }
  get(type, url) {
    if (!this.enabled) {
      return;
    }
    const key = `${type}::${url}`;
    const cachedFile = this.store.getKey(key);
    if (cachedFile) {
      if (type === "css") {
        this.hits.css++;
      } else {
        this.hits.font++;
      }
      if (cachedFile.type !== void 0) {
        return Buffer.from(cachedFile.data);
      }
      return cachedFile.data;
    }
  }
  save(type, url, data) {
    if (!this.enabled) {
      return;
    }
    const key = `${type}::${url}`;
    if (!this.store.getKey(key)) {
      if (type === "css") {
        this.count.css++;
      } else {
        this.count.font++;
      }
    }
    this.store.setKey(key, data);
    this.store.save(true);
  }
  all() {
    return this.store.all();
  }
  clear() {
    cache.clearCacheById(this.cacheID);
  }
};

// src/default-options.ts
var defaultOptions = {
  injectAsStyleTag: true,
  minifyCss: true,
  async: true,
  cache: true
};
var getOptionsWithDefaults = (options = {}) => {
  return {
    ...defaultOptions,
    ...options
  };
};

// src/index.ts
import { AxiosError } from "axios";
function viteWebfontDownload(_webfontUrls, _options) {
  if (!Array.isArray(_webfontUrls) && typeof _webfontUrls !== "string") {
    _webfontUrls = [];
  }
  if (typeof _webfontUrls === "string" && _webfontUrls !== "") {
    _webfontUrls = [_webfontUrls];
  }
  const webfontUrls = new Set(_webfontUrls || []);
  const webfontUrlsIndex = /* @__PURE__ */ new Set([]);
  const webfontUrlsCss = /* @__PURE__ */ new Set([]);
  const options = getOptionsWithDefaults(_options);
  let fonts = {};
  const cssFilename = "webfonts.css";
  const fontUrlsDevMap = /* @__PURE__ */ new Map();
  const fileCache = new FileCache(options);
  const cssLoader = new CssLoader(options, fileCache);
  const cssParser = new CssParser();
  const cssTransformer = new CssTransformer();
  const cssInjector = new CssInjector(options);
  const fontLoader = new FontLoader(fileCache);
  const indexHtmlProcessor = new IndexHtmlProcessor();
  let viteDevServer;
  let pluginContext;
  let resolvedConfig;
  let base;
  let assetsDir;
  let indexHtmlContent;
  let indexHtmlPath;
  let cssContent = "";
  let cssPath;
  const collectWebfontsFromIndexHtml = (indexHtml) => {
    webfontUrlsIndex.clear();
    for (const webfontUrl of indexHtmlProcessor.parse(indexHtml)) {
      webfontUrlsIndex.add(webfontUrl);
    }
  };
  const collectWebfontsFromBundleCss = (bundle) => {
    webfontUrlsCss.clear();
    for (const path in bundle) {
      if (path.match(/\.css$/)) {
        let bundleCssContent = bundle[path].source.toString();
        const parsedBundleCss = cssParser.parseBundleCss(
          bundleCssContent,
          base,
          assetsDir
        );
        if (parsedBundleCss.matchedCssParts.length) {
          fonts = {
            ...fonts,
            ...parsedBundleCss.fonts
          };
          parsedBundleCss.webfontUrlsCss.forEach((url) => {
            webfontUrlsCss.add(url);
          });
          parsedBundleCss.matchedCssParts.forEach((cssPart) => {
            bundleCssContent = bundleCssContent.replaceAll(cssPart, "");
            cssContent += cssPart + "\n";
          });
          bundle[path].source = bundleCssContent;
          cssContent = cssLoader.formatCss(
            cssContent,
            !!viteDevServer
          );
        }
      }
    }
  };
  const downloadWebfontCss = async () => {
    const allWebfontUrls = /* @__PURE__ */ new Set([
      ...webfontUrls,
      ...webfontUrlsIndex,
      ...webfontUrlsCss
    ]);
    if (allWebfontUrls.size) {
      cssContent += await cssLoader.loadAll(allWebfontUrls, !!viteDevServer);
    }
    if (!viteDevServer) {
      logInfo(
        colors.green("\u2713") + " [webfont-dl] " + allWebfontUrls.size.toString() + " css downloaded. " + colors.gray(
          options.cache !== false ? `[cache hit: ${fileCache.hits.css}/${fileCache.count.css}]` : "[cache disabled]"
        )
      );
    }
    return cssContent;
  };
  const parseFonts = (cssContent2) => {
    fonts = {
      ...fonts,
      ...cssParser.parse(cssContent2, base, assetsDir)
    };
  };
  const replaceFontUrls = () => {
    cssContent = cssTransformer.transform(cssContent, fonts);
  };
  const downloadFonts = async () => {
    for (const fontFileName in fonts) {
      const font = fonts[fontFileName];
      writeLine(`[webfont-dl] ${colors.gray(font.url)}`);
      const fontBinary = await fontLoader.load(font.url);
      font.localPath = base + saveFile(
        fontFileName,
        fontBinary
      );
    }
    logInfo(
      colors.green("\u2713") + " [webfont-dl] " + Object.keys(fonts).length.toString() + " fonts downloaded. " + colors.gray(
        options.cache !== false ? `[cache hit: ${fileCache.hits.font}/${fileCache.count.font}]` : "[cache disabled]"
      )
    );
  };
  const downloadFont = async (url) => {
    writeLine(`[webfont-dl] ${colors.gray(url)}`);
    const font = fontLoader.load(url);
    clearLine();
    return font;
  };
  const loadAndPrepareDevFonts = async () => {
    parseFonts(await downloadWebfontCss());
    replaceFontUrls();
    fontUrlsDevMap.clear();
    for (const fontFileName in fonts) {
      const font = fonts[fontFileName];
      fontUrlsDevMap.set(font.localPath, font.url);
    }
  };
  const saveCss = () => {
    cssPath = saveFile(
      cssFilename,
      cssContent
    );
  };
  const saveFile = (fileName, source) => {
    const ref = pluginContext.emitFile({
      name: fileName,
      type: "asset",
      source
    });
    return pluginContext.getFileName(ref);
  };
  const injectToHtml = (html, cssContent2) => {
    if (viteDevServer || options.injectAsStyleTag === false) {
      return cssInjector.injectAsStylesheet(html, base, cssPath);
    }
    return cssInjector.injectAsStyleTag(html, cssContent2);
  };
  const isTty = () => {
    return stdout.isTTY && !env.CI;
  };
  const logInfo = (output) => {
    clearLine();
    resolvedConfig.logger.info(output);
  };
  const clearLine = () => {
    if (isTty()) {
      stdout.clearLine(0);
      stdout.cursorTo(0);
    }
  };
  const writeLine = (output) => {
    if (isTty()) {
      clearLine();
      if (output.length < stdout.columns) {
        stdout.write(output);
      } else {
        stdout.write(output.substring(0, stdout.columns - 1));
      }
    } else {
      logInfo(output);
    }
  };
  return {
    name: "vite-plugin-webfont-dl",
    enforce: "post",
    configResolved(_resolvedConfig) {
      resolvedConfig = _resolvedConfig;
      base = resolvedConfig.base;
      assetsDir = resolvedConfig.build.assetsDir;
      cssPath = assetsDir + "/" + cssFilename;
      if (resolvedConfig.build.minify === false && (_options == null ? void 0 : _options.minifyCss) !== true) {
        options.minifyCss = false;
      }
    },
    configureServer(_viteDevServer) {
      viteDevServer = _viteDevServer;
      assetsDir = "@webfonts";
      cssPath = assetsDir + "/" + cssFilename;
      const handleDevServerWebfontsCss = (req, res) => {
        void (async () => {
          try {
            await loadAndPrepareDevFonts();
            res.end(cssContent);
          } catch (error) {
            console.error(
              colors.red("[webfont-dl]"),
              error.message
            );
            res.statusCode = 502;
            res.setHeader("X-Error", error.message.replace(/^Error: /, ""));
            res.end();
          }
        })();
      };
      const handleDevServerWebfont = (req, res) => {
        void (async () => {
          var _a;
          const url = (_a = req.originalUrl) == null ? void 0 : _a.replace(/[?#].*$/, "");
          res.setHeader("Access-Control-Allow-Origin", "*");
          res.end(
            await downloadFont(
              fontUrlsDevMap.get(url)
            )
          );
        })();
      };
      viteDevServer.middlewares.use(
        base + cssPath,
        handleDevServerWebfontsCss
      );
      viteDevServer.middlewares.use(
        base + cssFilename,
        handleDevServerWebfontsCss
      );
      viteDevServer.middlewares.use((req, res, next) => {
        var _a;
        const url = (_a = req.originalUrl) == null ? void 0 : _a.replace(/[?#].*$/, "");
        if (!url) {
          return next();
        }
        if (url.match(/\.(?:woff2?|eot|ttf|otf|svg)$/) && fontUrlsDevMap.has(url)) {
          handleDevServerWebfont(req, res);
        } else {
          next();
        }
      });
    },
    transformIndexHtml(html, ctx) {
      indexHtmlContent = html;
      indexHtmlPath = ctx.path.replace(/^\//, "");
      if (viteDevServer) {
        collectWebfontsFromIndexHtml(html);
        html = indexHtmlProcessor.removeTags(html);
        html = injectToHtml(html);
      }
      return html;
    },
    async generateBundle(_options2, bundle) {
      pluginContext = this;
      if (indexHtmlContent !== void 0) {
        collectWebfontsFromIndexHtml(indexHtmlContent);
      }
      collectWebfontsFromBundleCss(bundle);
      try {
        parseFonts(await downloadWebfontCss());
        await downloadFonts();
        replaceFontUrls();
        if (options.injectAsStyleTag === false || indexHtmlContent === void 0) {
          saveCss();
        }
        if (bundle[indexHtmlPath] !== void 0) {
          indexHtmlContent = indexHtmlProcessor.removeTags(indexHtmlContent);
          indexHtmlContent = injectToHtml(indexHtmlContent, cssContent);
          bundle[indexHtmlPath].source = indexHtmlContent;
        }
      } catch (error) {
        console.error(colors.red(
          `[webfont-dl] ${error.message}`
        ));
        if (error instanceof AxiosError) {
          if (error.request instanceof ClientRequest) {
            console.error(colors.red(
              `[webfont-dl] ${error.request.method} ${error.request.protocol}//${error.request.host}${error.request.path}`
            ));
          }
        }
      }
    }
  };
}
export {
  viteWebfontDownload as ViteWebfontDownload,
  viteWebfontDownload as default,
  viteWebfontDownload as viteWebfontDl,
  viteWebfontDownload,
  viteWebfontDownload as webfontDl,
  viteWebfontDownload as webfontDownload
};
